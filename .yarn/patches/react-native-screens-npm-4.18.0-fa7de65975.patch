diff --git a/ios/RNSScreenStack.mm b/ios/RNSScreenStack.mm
index 51f021831aed26a4eed3c85014020423b7b3108b..4998d946f8a2e83a0ed200d090a02523815b43ff 100644
--- a/ios/RNSScreenStack.mm
+++ b/ios/RNSScreenStack.mm
@@ -640,8 +640,10 @@ RNS_IGNORE_SUPER_CALL_END
 
   // This check is for external modals that are not owned by this stack. They can prevent the dismissal of the modal by
   // extending RNSDismissibleModalProtocol and returning NO from isDismissible method.
-  if (![firstModalToBeDismissed conformsToProtocol:@protocol(RNSDismissibleModalProtocol)] ||
-      [(id<RNSDismissibleModalProtocol>)firstModalToBeDismissed isDismissible]) {
+  BOOL shouldDismissFirstModal = ![firstModalToBeDismissed conformsToProtocol:@protocol(RNSDismissibleModalProtocol)] ||
+      [(id<RNSDismissibleModalProtocol>)firstModalToBeDismissed isDismissible];
+
+  if (shouldDismissFirstModal) {
     if (firstModalToBeDismissed != nil) {
       const BOOL firstModalToBeDismissedIsOwned = [firstModalToBeDismissed isKindOfClass:RNSScreen.class];
       const BOOL firstModalToBeDismissedIsOwnedByThisStack =
@@ -699,6 +701,33 @@ RNS_IGNORE_SUPER_CALL_END
         return;
       }
     }
+  } else {
+    // Modal is non-dismissible (e.g., third-party modal like TrueSheet)
+    // Check if the external modal provides a presenting controller
+    if (firstModalToBeDismissed != nil) {
+      id<RNSDismissibleModalProtocol> dismissibleModal = (id<RNSDismissibleModalProtocol>)firstModalToBeDismissed;
+      UIViewController *presentingController = nil;
+
+      // Check if the external modal implements the optional method
+      if ([dismissibleModal respondsToSelector:@selector(presentingControllerForModals)]) {
+        presentingController = [dismissibleModal presentingControllerForModals];
+      }
+
+      // Only handle the non-dismissible modal if it provides a presenting controller
+      if (presentingController != nil) {
+        changeRootController = presentingController;
+
+        // Check if the presenting controller has presented modals that need to be dismissed
+        UIViewController *modalPresentedByController = presentingController.presentedViewController;
+        if (modalPresentedByController != nil && ![modalPresentedByController isBeingDismissed] &&
+            [_presentedModals containsObject:modalPresentedByController]) {
+          // The presenting controller has presented one of our modals
+          // We need to dismiss it before presenting new ones
+          [presentingController dismissViewControllerAnimated:YES completion:finish];
+          return;
+        }
+      }
+    }
   }
 
   // We didn't detect any controllers for dismissal, thus we start presenting new VCs
diff --git a/ios/integrations/RNSDismissibleModalProtocol.h b/ios/integrations/RNSDismissibleModalProtocol.h
index 006f809d104c1d4fbdf6eccca89d6c6e190cca71..9991c28f42ec63a40b2e8b2e74d066eecbfad615 100644
--- a/ios/integrations/RNSDismissibleModalProtocol.h
+++ b/ios/integrations/RNSDismissibleModalProtocol.h
@@ -1,3 +1,5 @@
+#import <UIKit/UIKit.h>
+
 NS_ASSUME_NONNULL_BEGIN
 
 @protocol RNSDismissibleModalProtocol <NSObject>
@@ -6,6 +8,13 @@ NS_ASSUME_NONNULL_BEGIN
 // Use it on your own responsibility, as it can lead to unexpected behavior.
 - (BOOL)isDismissible;
 
+@optional
+// If the modal is non-dismissible, it can optionally provide a view controller
+// that should be used as the presenting controller for subsequent modals.
+// This gives the external modal implementation control over the presentation chain.
+// If not implemented or returns nil, the non-dismissible modal itself will be used.
+- (nullable UIViewController *)presentingControllerForModals;
+
 @end
 
 NS_ASSUME_NONNULL_END
