diff --git a/ios/RNSScreen.mm b/ios/RNSScreen.mm
index 65c18f1ddccc64b3169e050e577eab77fd8c183b..8ffd9d4b48f85e53c6fcf0a76963cfcf946dad97 100644
--- a/ios/RNSScreen.mm
+++ b/ios/RNSScreen.mm
@@ -38,6 +38,7 @@
 #import "RNSTabBarController.h"
 
 #import "RNSDefines.h"
+#import "integrations/RNSLifecycleListenerProtocol.h"
 #import "UIView+RNSUtility.h"
 
 #ifdef RCT_NEW_ARCH_ENABLED
@@ -74,6 +75,7 @@ struct ContentWrapperBox {
   ContentWrapperBox _contentWrapperBox;
   bool _sheetHasInitialDetentSet;
   BOOL _shouldUpdateScrollEdgeEffects;
+  RNSScreen *_controllerBeforeInvalidate;
 #ifdef RCT_NEW_ARCH_ENABLED
   RCTSurfaceTouchHandler *_touchHandler;
   react::RNSScreenShadowNode::ConcreteState::Shared _state;
@@ -608,6 +610,26 @@ RNS_IGNORE_SUPER_CALL_END
   if (_hideKeyboardOnSwipe) {
     [self endEditing:YES];
   }
+
+  // Notify any presented view controllers that conform to RNSLifecycleListenerProtocol
+  RNSScreen *controller = _controller ?: _controllerBeforeInvalidate;
+  if (controller) {
+    UIViewController *presented = controller.presentedViewController;
+    while (presented) {
+      UIViewController *next = presented.presentedViewController;
+      if ([presented conformsToProtocol:@protocol(RNSLifecycleListenerProtocol)]) {
+        BOOL isPresenterUnmounting = NO;
+        RNSScreen *presenter = (RNSScreen *)presented.presentingViewController;
+        if ([presenter isKindOfClass:[RNSScreen class]]) {
+          isPresenterUnmounting = presenter.screenView.isMarkedForUnmountInCurrentTransaction;
+        }
+        [(id<RNSLifecycleListenerProtocol>)presented screenWillDisappear:controller
+                                                   isPresenterUnmounting:isPresenterUnmounting];
+      }
+      presented = next;
+    }
+  }
+
 #ifdef RCT_NEW_ARCH_ENABLED
   // If screen is already unmounted then there will be no event emitter
   if (_eventEmitter != nullptr) {
@@ -927,6 +949,9 @@ RNS_IGNORE_SUPER_CALL_END
 
 - (void)invalidate
 {
+  if (_controller && !_controllerBeforeInvalidate) {
+    _controllerBeforeInvalidate = _controller;
+  }
   _controller = nil;
   [_sheetsScrollView removeObserver:self forKeyPath:@"bounds" context:nil];
 }
diff --git a/ios/RNSScreenStack.mm b/ios/RNSScreenStack.mm
index 51f021831aed26a4eed3c85014020423b7b3108b..268fa69dfee2b20d8b5a66c77c1b4cbd8c831573 100644
--- a/ios/RNSScreenStack.mm
+++ b/ios/RNSScreenStack.mm
@@ -640,8 +640,10 @@ RNS_IGNORE_SUPER_CALL_END
 
   // This check is for external modals that are not owned by this stack. They can prevent the dismissal of the modal by
   // extending RNSDismissibleModalProtocol and returning NO from isDismissible method.
-  if (![firstModalToBeDismissed conformsToProtocol:@protocol(RNSDismissibleModalProtocol)] ||
-      [(id<RNSDismissibleModalProtocol>)firstModalToBeDismissed isDismissible]) {
+  BOOL shouldDismissFirstModal = ![firstModalToBeDismissed conformsToProtocol:@protocol(RNSDismissibleModalProtocol)] ||
+      [(id<RNSDismissibleModalProtocol>)firstModalToBeDismissed isDismissible];
+
+  if (shouldDismissFirstModal) {
     if (firstModalToBeDismissed != nil) {
       const BOOL firstModalToBeDismissedIsOwned = [firstModalToBeDismissed isKindOfClass:RNSScreen.class];
       const BOOL firstModalToBeDismissedIsOwnedByThisStack =
@@ -699,6 +701,33 @@ RNS_IGNORE_SUPER_CALL_END
         return;
       }
     }
+  } else {
+    // Modal is non-dismissible (e.g., third-party modal like TrueSheet)
+    // Check if the external modal provides a presenting controller
+    if (firstModalToBeDismissed != nil) {
+      id<RNSDismissibleModalProtocol> dismissibleModal = (id<RNSDismissibleModalProtocol>)firstModalToBeDismissed;
+      UIViewController *presentingController = nil;
+
+      // Check if the external modal implements the optional method
+      if ([dismissibleModal respondsToSelector:@selector(newPresentingViewController)]) {
+        presentingController = [dismissibleModal newPresentingViewController];
+      }
+
+      // Only handle the non-dismissible modal if it provides a presenting controller
+      if (presentingController != nil) {
+        changeRootController = presentingController;
+
+        // Check if the presenting controller has presented modals that need to be dismissed
+        UIViewController *modalPresentedByController = presentingController.presentedViewController;
+        if (modalPresentedByController != nil && ![modalPresentedByController isBeingDismissed] &&
+            [_presentedModals containsObject:modalPresentedByController]) {
+          // The presenting controller has presented one of our modals
+          // We need to dismiss it before presenting new ones
+          [presentingController dismissViewControllerAnimated:YES completion:finish];
+          return;
+        }
+      }
+    }
   }
 
   // We didn't detect any controllers for dismissal, thus we start presenting new VCs
diff --git a/ios/integrations/RNSDismissibleModalProtocol.h b/ios/integrations/RNSDismissibleModalProtocol.h
index 006f809d104c1d4fbdf6eccca89d6c6e190cca71..89e297f1b7a9582fee3e19237dfba8d4c87a352f 100644
--- a/ios/integrations/RNSDismissibleModalProtocol.h
+++ b/ios/integrations/RNSDismissibleModalProtocol.h
@@ -1,3 +1,5 @@
+#import <UIKit/UIKit.h>
+
 NS_ASSUME_NONNULL_BEGIN
 
 @protocol RNSDismissibleModalProtocol <NSObject>
@@ -6,6 +8,13 @@ NS_ASSUME_NONNULL_BEGIN
 // Use it on your own responsibility, as it can lead to unexpected behavior.
 - (BOOL)isDismissible;
 
+@optional
+// If the modal is non-dismissible, it can optionally provide a view controller
+// that should be used as the presenting controller for subsequent modals.
+// This gives the external modal implementation control over the presentation chain.
+// If not implemented or returns nil, the non-dismissible modal itself will be used.
+- (nullable UIViewController *)newPresentingViewController;
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/ios/integrations/RNSLifecycleListenerProtocol.h b/ios/integrations/RNSLifecycleListenerProtocol.h
new file mode 100644
index 0000000000000000000000000000000000000000..025b4231c0b45f9f10034280037617b9b6d6fec4
--- /dev/null
+++ b/ios/integrations/RNSLifecycleListenerProtocol.h
@@ -0,0 +1,14 @@
+#import <UIKit/UIKit.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@protocol RNSLifecycleListenerProtocol <NSObject>
+
+// Called when a screen in the presenting hierarchy is about to disappear.
+// @param screen The screen controller that is disappearing
+// @param isPresenterUnmounting YES if the presenter (modal) itself is being unmounted
+- (void)screenWillDisappear:(UIViewController *)screen isPresenterUnmounting:(BOOL)isPresenterUnmounting;
+
+@end
+
+NS_ASSUME_NONNULL_END
